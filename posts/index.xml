<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 小松的学习笔记</title>
    <link>https://wangsong.site/posts/</link>
    <description>Recent content in Posts on 小松的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_CN</language>
    <lastBuildDate>Sun, 10 Nov 2019 09:45:24 +0800</lastBuildDate>
    
	<atom:link href="https://wangsong.site/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>工具类7 StringBuffer&#43;StringBuilder&#43;Regex</title>
      <link>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB7-stringbuffer&#43;stringbuilder&#43;reqex/</link>
      <pubDate>Sun, 10 Nov 2019 09:45:24 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB7-stringbuffer&#43;stringbuilder&#43;reqex/</guid>
      <description>字符串相关的类 java.lang包
String  实现接口Serializable,CharSequence,Comparable
 非常特殊的类 可以像常量一样创建对象 String str=&amp;quot;abc&amp;quot;;
 内存存储 &amp;ldquo;abc&amp;rdquo;对象 char[] value
 String不可变特性 private final char[] value;
 频繁的修改其内容的时候，性能很不好
  StringBuffer/StringBuilder  所属的包 java.lang包
 默认继承AbstractStringBuilder 间接继承Object 实现接口 Serializable,CharSequence,Appendable
StringBuffer/StringBuilder 没有compareTo方法
StringBuffer/StringBuilder含有一个String没有的方法append(); 拼接
 特性
可变字符串 char[] value， 动态扩容
 对象的构建
//无参数构造方法 构建一个默认长度16个空间的对象 StringBuilder builder = new StringBuilder(); //利用给定的参数 构建一个自定义长度空间对象 char[] StringBuilder builder = new StringBuilder(20); //利用带String参数的构造方法 默认数组长度+16个 StringBuilder builder = new StringBuilder(&amp;quot;abc&amp;quot;);  StringBuilder中常用的方法</description>
    </item>
    
    <item>
      <title>工具类6 String常用方法练习</title>
      <link>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB6-string%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Sun, 10 Nov 2019 09:44:47 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB6-string%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0/</guid>
      <description>小任务(以下任务要求设计成方法)
1.设计一个方法 将字符串反转 ok&amp;ndash;&amp;gt;ko
2.设计一个方法 将给定字符串的正序和反序进行连接 ok&amp;ndash;&amp;gt;okko
3.设计一个方法 判断给定字符串是否是回文 abccba abcba
4.设计一个方法 将给定字符串右移x位置 (helloword,2)&amp;ndash;&amp;gt;ldhellowor
5.设计一个方法 寻找若干字符串中最长的那个 ab,abc,abcd&amp;ndash;&amp;gt;abcd
6.设计一个方法 统计给定字母在字符串中出现的次数 &amp;ldquo;this is a test of java&amp;rdquo;,&amp;ldquo;a&amp;rdquo;&amp;ndash;&amp;gt;3
7.设计一个方法 将给定的字符串每一个首字母大写 &amp;ldquo;this is a test of java&amp;rdquo;&amp;ndash;&amp;gt;&amp;ldquo;This Is A Test Of Java&amp;rdquo;
8.设计一个方法 获取给定字符串中的全部数字 &amp;ldquo;za1o1zbp24tcq&amp;rdquo;&amp;ndash;&amp;gt;1124</description>
    </item>
    
    <item>
      <title>工具类5 String常用方法</title>
      <link>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB5-string%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 10 Nov 2019 09:44:21 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB5-string%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description> boolean = equals(Object obj);//继承自Object,equals默认比较地址,被String重写了,比较两个字符串内容 int = hashCode();//继承自Object,被String重写,将当前字符串的每一个cahr元素拆开 乘以31求和 int = compareTo(String str);//实现自Comparable接口，按字典(Unicode编码)索引顺序比较 str1.compareTo(str2); //按照两个字符串长度较短的那个作为比较循环的次数 //挨个比较元素 str1[i]-str2[i]不为0就返回 //如果循环过后发现所有的字符都一样 len1-len2 //返回0表示两个字符相等 String = toString();//继承自Object,被String重写了,不在输出 类名@hashCode,而是字符串中的字面值 char = charAt(int index);//&amp;quot;abc&amp;quot; 0-&amp;gt;&#39;a&#39; //返回给定index对应位置的那个char值 int = codePointAt(int index);//&amp;quot;abc&amp;quot; 0-&amp;gt;97 //返回给定index对应位置的那个char所对应的code码 int = length();//返回字符串的长度(其实就是底层char[] value属性的长度) 注意:区别数组length是属性 String的length()为方法 集合size()为方法 String = concat(String);//将给定的字符串拼接在当前字符串之后 //此处要注意String对象的不可变特性 String str = &amp;quot;ab&amp;quot;; str = str.concat(&amp;quot;c&amp;quot;);//将str重新赋值才能得到&amp;quot;abc&amp;quot; //concat拼接字符串比+拼接性能高 String str = &amp;quot;a&amp;quot;+&amp;quot;b&amp;quot;+&amp;quot;c&amp;quot;+&amp;quot;d&amp;quot;;//数学计算 拼接符号 system.out.println(str);//过程中产生了几个String对象? 字符串常量池7个 //对象1-&amp;gt;value[] a &amp;quot;a&amp;quot; //对象2-&amp;gt;value[] b &amp;quot;b&amp;quot; //对象3-&amp;gt;value[] {a,b} &amp;quot;ab&amp;quot; //对象4-&amp;gt;value[] c &amp;quot;c&amp;quot; //对象5-&amp;gt;value[] {a,b,c} &amp;quot;abc&amp;quot; //对象6-&amp;gt;value[] d &amp;quot;d&amp;quot; //对象7-&amp;gt;value[] {a,b,c,d} &amp;quot;abcd&amp;quot; boolean = contains(CharSequence s);//判断给定的s是否在字符串中存在 starstWith(String prefix); endsWith(String suffix); //判断次字符串是否以xx开头/结尾 byte[] = getBytes(); char[] = toCharArray(); //将当前子字符串转化成数组 int = indexOf(int/String str[,int fromIndex]);//四个方法重载 //找寻给定的元素在字符串中第一次初选的索引位置,若字符串不存在则返回-1 int = lastIndexOf(int/String str[,int fronIndex]); //找寻给定的元素在字符串中最后一次出现的索引位置,若不存在则返回-1 boolean = isEmpty(); //判断当前字符串是否为空字符串(length是否为0) //注意与null之间的区别 replace(target,replacement); replaceAll(target,replacement);//前两个所有出现的都能换 replaceFirst(target,replacement);//第三个只换第一次出现的 //将给定的字符串替换成另外的字符串 String[] = split(String regex[,int limit]);//按照给定的表达式将原来的字符串拆分开 &amp;quot;a-b-c-d&amp;quot; &amp;quot;-&amp;quot; String = substring(int beginIndex[,int endIndex]); //[beginIndex,endIndex) //将当前的字符串截取一部分,若ebdIndex不写 则默认到字符串最后 String = tpUpperCase(); String = tpLowerCase(); //将全部字符串转换成大写/小写 String = trim(); //去掉字符串前后多余的空格 boolean = matches(String regex);//匹配正则表达式 //regular expression 正则表达式  </description>
    </item>
    
    <item>
      <title>工具类4 String不可变特性及常用方法</title>
      <link>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB4-string%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%89%B9%E6%80%A7%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 10 Nov 2019 09:43:49 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB4-string%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%89%B9%E6%80%A7%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>String类-&amp;gt;引用类型 java.lang包
常见的String笔试题 == equals方法的区别 String的不可变特性 StringBuffer与StringBuilder区别 String对象的存储 String中常用的方法*  1. 存在哪 java.lang包 没有任何继承关系，实现三个接口 Serializable,CharSequence,Comparable&amp;lt;&amp;gt;
2. 如何构建对象  String str = &amp;quot;abc&amp;quot;;//直接将字符串常量赋值给str (字符串常量池) String str = new String();//String str = &amp;quot;&amp;quot;;无参数构造方法创建空的对象 String str = new String(&amp;quot;abc&amp;quot;);//String str = &amp;quot;abc&amp;quot;;带String参数的构造方法创建对象 String str = new String(byte[]);//将数组中的每一个元素转化成对应的char 组合成String String str = new String(char[]);//将数组中的每一个char元素拼接成String String str = new String(&amp;quot;hello&amp;quot;,1,3);//str=&amp;quot;ell&amp;quot;; String的重载，从一号向右偏移三位拼接  3. == equals方法的区别  ==可以比较基本类型，可以比较引用类型。比较基本类型比较值，比较引用类型比较地址 equals只能比较引用类型(方法)，默认比较地址this==obj。如果想要改变其比较规则，可以重写equals方法。通常重写equals方法时会伴随着重写hashCode方法  4. String的不可变特性*  体现在两个地方:长度和内容 private final char value[]; // 在String类中包含一个数组value,存储String中的每一个字符 长度-&amp;gt;final修饰的数组,数组长度本身不变,final修饰数组的地址也不变 内容-&amp;gt;private修饰的属性,不能在类的外部访问  5.</description>
    </item>
    
    <item>
      <title>工具类3 日期相关&#43;String</title>
      <link>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB3-%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3&#43;string/</link>
      <pubDate>Sun, 10 Nov 2019 09:43:16 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB3-%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3&#43;string/</guid>
      <description></description>
    </item>
    
    <item>
      <title>工具类2 数学相关</title>
      <link>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB2-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sun, 10 Nov 2019 09:42:47 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB2-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</guid>
      <description>包装类 数学相关 日期相关 字符串相关 集合相关 异常相关 I/O相关 线程相关 网络相关 反射相关 GUI相关
与数学相关的类 1.所属的包java.lang
2.Math构造方法是私有的，我们不能直接调用创建对象
3.由于Math中提供的属性及方法都是static，不需要创建对象
4.常用方法
abs(*) int //给定数字的绝对值 ceil(Double) int //向上取整 floor(Double) int //向下取整 rint(Double) int //临近的整数，如果两边距离一样则返回偶数 round(Double) int //四舍五入 max(a,b); min(a,b); //int long float double 最大最小值 pow(a,b); //a的b次方(参数double 返回值double) sqrt(a); //取平方根 double = random(); //随机产生一个[0.0~1.0)  5.Math.random()计算小数的时候精确度可能会有些损失
0~9之间的随机整数 int value = (int)(Math.random()*10); 5.0~10.9之间的小数 (Math.random()*6)+5 0.0~0.999999 *6 --&amp;gt;0.0~5.49999  Random类 1.在java.util包中的类，需要import导入
2.没有任何继承 关系，默认继承Object
3.查找构造方法&amp;mdash;&amp;gt;如何创建对象
Random r = new Random();  4.</description>
    </item>
    
    <item>
      <title>工具类1 包装类</title>
      <link>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB1-%E5%8C%85%E8%A3%85%E7%B1%BB/</link>
      <pubDate>Sun, 10 Nov 2019 09:42:00 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/%E5%B7%A5%E5%85%B7%E7%B1%BB1-%E5%8C%85%E8%A3%85%E7%B1%BB/</guid>
      <description>研究内容  类所在的包 类的关系,自己默认继承,实现 类中提供的常用方法 是否可以创建对象,调用,方法本身静态  包装类(封装类) byte---Byte short---Short int---Integer long---Long float---Float double---Double char---Character boolean---Boolean   八个包装类都在同一个包下java.lang包, 不需要import导包直接使用
 八个包装类中有六个是与数字相关的,都默认继承父类Number
 八个包装类都实现了Serializable,Comparable接口
 八个包装类都有带自己对应类型参数的构造方法 八个包装类中有七个(除了Character)还有构造方法重载 带String类型
new Interger(10); new Interger(&amp;quot;10&amp;quot;);  创建对象 对象调用方法
有六个是与数字相关的类继承Number xxxValue(); 将一个包装类类型转化为对应的基本类型(拆包)
Integer i1 = new Integer(10);//引用数据类型 包装类 int value = i1.intValue(); //1.5版本之后 自动拆装包 Integer i2 = 10; int value = new Integer(10); //两种方法将String转化为int int value = Integer.parseInt(&amp;quot;123&amp;quot;); int value = new Integer(&amp;quot;123&amp;quot;);  经常在笔试中出现的问题</description>
    </item>
    
    <item>
      <title>Java、Maven的包管理</title>
      <link>https://wangsong.site/posts/javamaven%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 29 Oct 2019 11:53:59 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/javamaven%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description> Java的包管理机制 包管理的本质就是告诉JVM如何找到所需的第三方类库，以及成功地解决其中的冲突问题。
JVM的包管理机制非常简单：
 JVM一辈子只干一件事，读字节码文件，执行字节码。 每当JVM看到一个全限定类名，就尝试从classpath中加载。  要找一个类就在-classpath所指定的jar包(一堆类的压缩包)或文件夹中按照全限定类名(目录层级)挨个查找，找到为止，找不到就会丢出一个ClassNotFoundExeption。
当多个同名类同时出现在classpath中，JVM就只会加载放在前面的类，导致了放在后面的想要使用的类得不到使用，这就是Classpath hell。
由于传递性依赖，我们依赖的类可能还依赖类其他的类，classpath中会将所有依赖的类引用进来，这就导致classpath非常长，要解决Classpath hell，人工寻找classpath中的同名类非常困难，这就需要借助自动化工具来实现。
Maven的包管理机制 Maven的仓库
 Maven的中央仓库：按照一定的约定存储包 Maven的本地仓库：默认位于~/.m2,下载的第三方包放在这里进行缓存  Maven按照约定为所有的包编号：groupId/artifactId/version，方便检索。
当我们需要一个包时，Maven按照我们给出的编号，去仓库查找这个包，并根据依赖找到所有的包下载到本地，然后拼接成一个很长的classpath，以供JVM查找加载。
作为依赖性的自动管理工具，Maven绝对不允许最终的classpath出现同名不同版本的jar包，其解决依赖冲突的原则是：距离本项目最近的胜出 。 但这一原则并不能总是让我们得到需要的包，当看到这些异常的的时候，说明Maven解决不了这个包冲突，需要靠手动解决。
AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError  包管理冲突的解决 以运行一个程序得到如下异常为例:
首先对冲突的包进行定位，可以从Maven的Dependency中找到对应的两个包，可以看到此项目中只有两个org.springframework:spring-web的包，5.1.8版本不受其他包所依赖，距离本项目较4.3.6版本更近，所以Maven是采用了5.1.8版本，所以我们可以很快地定位到运行项目缺失的类方法是在4.3.6版本中。
但是，如果这里发生冲突的包不止有两个呢？这时，就需要到Maven的中央仓库去查看源码进行定位了。
定位到了发生冲突的包，那么接下来就该解决问题了。
方法一 在最近处添加一个新的包 在pom.xml文件中引入一个4.3.6版本的dependency即可
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.3.6.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  方法二 消除与其冲突的包 如果5.1.8版本包不被其他包所依赖，直接在pom.xml文件中将其dependency删去或者注释掉即可；如果5.1.8版本包受其他包所依赖，可在上级包的dependency中添加如下内容即可将5.1.8版本包从其中排除不受依赖。
&amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt;  </description>
    </item>
    
    <item>
      <title>如何使用Hugo搭建个人博客</title>
      <link>https://wangsong.site/posts/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 28 Oct 2019 10:55:57 +0800</pubDate>
      
      <guid>https://wangsong.site/posts/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
      <description>Hugo是由Go语言实现的静态网站生成器，可以快速搭建一套静态展示类型的网站。并且自带高性能服务器，热部署等特性，是不想多花精力又想构建个人博客的极佳选择。本文将介绍如何使用Hugo搭建个人博客及如何发布到Github并生成Github pages。
快速搭建博客 进入Hugo 官网，点击Quick Start快速开始。
安装Hugo Windows安装方式  去Hugo releases页面下载hugo_xxx_Windows-64bit.zip 解压，把hugo.exe放到D:\Software\hugo\hugo.exe 把D:\Software\hugo加到PATH 重启终端，运行hugo version 查看版本  Mac安装方式  brew install hugo hugo version  建立新站点 输入命令
hugo new site github.io-creator  在当前文件夹中创建一个新的Hugo网站github.io-creator。
添加主题 依次输入下面四条命令，下载并使用主题ananke。
cd github.io-creator git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml  更换主题可到Hugo的官方网站浏览下载。
创建文章 输入命令
hugo new posts/我的博客.md  Hugo会在content目录下创建post目录，在post目录下创建scala-learning-pattern-matching.md文件。之后打开md文件，里面已经有些内容：
这里的的draft默认状态为true,需要修改为false才能发布。
查看生成的文章 草稿状态下 输入命令hugo sever -D
非草稿状态下 输入hugo sever
可得到如下结果：</description>
    </item>
    
  </channel>
</rss>